### Стратегия безопасности и приватности

**Цель:** Определить комплекс мер для защиты данных пользователя, обеспечения безопасности каналов связи и самого приложения, а также соблюдения принципов приватности.

## 1. Данные в состоянии покоя (Data at Rest)

### 1.1. Шифрование базы данных
- **Решение:** использовать полное шифрование локальной БД Room через SQLCipher.
- **Управление ключами:**
  - Ключ шифрования (passphrase, 32 байта) генерируется при первом запуске через криптографически стойкий `SecureRandom`.
  - Ключ сохраняется в Android Keystore косвенно, через `EncryptedSharedPreferences` с `MasterKey(AES256_GCM)`; пары ключ/значение шифруются схемой AES‑SIV/AES‑GCM.
  - Инициализация Room выполняется с `SupportSQLiteOpenHelperFactory(passphrase)` (см. `docs/20_DATA_LAYER/01_DATABASE.md` → «Стратегия шифрования»).
- **Обработка потери ключа:**
  - Если Keystore становится невалидным (например, после сброса PIN/пароля, сброса устройства) и passphrase расшифровать невозможно: выполняется принудительный logout, полная очистка локальных данных (Room, кэш, очереди), повторная инициализация ключей при новом входе.

### 1.2. Хранилище ключ‑значение
- **Решение:** секреты и сессионные токены (Firebase ID/Refresh Token, FCM token при необходимости) хранятся в `EncryptedSharedPreferences`.
- Неструктурные пользовательские настройки, не являющиеся секретом, допускаются в DataStore/SharedPreferences, но без токенов и PII.

### 1.3. Файловое хранилище
- Кэш медиа (например, аватары) хранится во внутреннем приватном хранилище приложения (`context.filesDir`/`cacheDir`).
- Запрещено использовать общедоступные каталоги для чувствительных данных. Временные файлы очищаются по политике TTL/при logout.

## 2. Данные при передаче (Data in Transit)

### 2.1. HTTPS / TLS
- **Правило:** весь HTTP‑трафик только по HTTPS. Включить `HSTS` на бекенде; на клиенте запретить cleartext трафик в `Network Security Config`.
- **Certificate Pinning (рекомендация):** рассмотреть добавление pinning для публичного API (OkHttp CertificatePinner) c ротацией ключей; фиксируется как продуктовая рекомендация для продакшена.

### 2.2. Безопасность BLE‑соединения
- Канонический источник: `docs/20_DATA_LAYER/03_BLE_PROTOCOL.md` (раздел «Безопасность BLE‑соединения»).
- **Ключевые положения:**
  - Использовать LE Secure Connections (Bluetooth 4.2+) с AES‑128‑CCM.
  - Для v2.0 — приоритетный метод сопряжения Out of Band (OOB) через NFC; резерв — Passkey Entry; Just Works только в debug.
  - Аутентифицированный и зашифрованный доступ к критичным GATT характеристикам (команды, OTA, загрузка анимаций); минимальные права к публичным характеристикам.
  - Защита от MITM/replay; политика flow‑control и валидации размеров сообщений.

## 3. Аутентификация и авторизация

### 3.1. Управление токенами
- Источник истины по auth — Firebase Auth.
- **Жизненный цикл Firebase ID Token:**
  - Получение через Firebase Auth SDK; автоматическое обновление SDK.
  - Безопасное хранение в `EncryptedSharedPreferences` (refresh/id tokens и вспомогательные данные сессии).
  - Передача на сервер в заголовке `Authorization: Bearer <id_token>` через интерсептор `:core:network`.

### 3.2. App Check
- **Обязательное требование:** App Check должен сопровождать все вызовы к API/бэкенду. Проверка и прикрепление токена выполняется в сетевом слое, запросы без валидного App Check отвергаются.

## 4. Безопасность на уровне приложения

### 4.1. Защита кода
- Обязательная обфускация/оптимизация релизных сборок ProGuard/R8. Конфигурации должны исключать утечки чувствительных строк и отражать минимально необходимую рефлексию.

### 4.2. Защита от реверс‑инжиниринга
- Детекция рутованных/скомпрометированных устройств (root/jailbreak indicators). При обнаружении — информировать пользователя и/или ограничивать функциональность, чувствительную к рискам (например, офлайн‑операции высокой ценности).

### 4.3. Защита UI
- На экранах с чувствительной информацией (например, ввод секретного кода пары, показ одноразовых токенов) устанавливать `FLAG_SECURE` для запрета скриншотов/записи экрана.

## 5. Приватность (Privacy by Design)

### 5.1. Принцип минимизации данных
- Приложение собирает и хранит только те данные, которые необходимы для предоставления функциональности. Локальные модели и схемы БД минимизируют PII, payload’ы нормализуются (см. `docs/20_DATA_LAYER/01_DATABASE.md`).

### 5.2. Согласия (Consents)
- Механизм согласий описан в `docs/50_CROSS_CUTTING_CONCERNS/02_LOGGING_AND_TELEMETRY.md`. Любая телеметрия, аналитика и отчёт об ошибках отправляются только при наличии явного согласия.

### 5.3. Обработка PII
- **Определение PII в контексте приложения:** имя/ник, email, фото/аватар, идентификаторы аккаунта/устройств, контактные идентификаторы; потенциально — геолокация (в будущем), история взаимодействий, если она может однозначно идентифицировать пользователя.
- **Золотое правило:** PII никогда не должны попадать в логи. Логирование и телеметрия обязаны фильтровать PII и использовать псевдонимизацию/хэширование идентификаторов при необходимости (см. «Запрет персональных данных (PII)» в `02_LOGGING_AND_TELEMETRY.md`).

## 6. Операционные требования и соответствие архитектуре

- Локальная БД Room — единственный источник истины для офлайн‑данных; применяется SQLCipher, политика очистки при logout и при потере ключа (см. `01_DATABASE.md`).
- Сетевой стек `:core:network` обеспечивает: TLS‑транспорт, `Authorization: Bearer`, App Check, retry/backoff и (в релизе) отключение подробного логирования тела ответов.
- BLE стек `:core:ble` реализует политику безопасного соединения, flow‑control, таймауты/ретраи и разграничение доступа к характеристикам (см. `03_BLE_PROTOCOL.md`).
- Логирование/телеметрия (`02_LOGGING_AND_TELEMETRY.md`): уровни VERBOSE/DEBUG отключены в release; ошибки отправляются в Crashlytics только с учетом согласий; исключается PII.
- Release‑сборки подписываются и проходят обфускацию; debug‑фичи (Just Works, подробные логи) недоступны в продакшене.

## 7. Проверочные списки (для команд)

### Разработчики
- Внести/проверить SQLCipher и `EncryptedSharedPreferences` интеграции.
- Проверить интерсепторы `Authorization` и App Check во всех API вызовах.
- Установить `FLAG_SECURE` на чувствительных экранах.
- Убедиться, что в release отключены VERBOSE/DEBUG логи; в коде отсутствуют прямые логи с PII/секретами.
- Для BLE: обеспечить использование защищенных методов сопряжения и ограничение доступа к критичным характеристикам.

### QA
- Проверить поведение при потере Keystore (сброс блокировки экрана): приложение должно делать logout и очищать локальные данные.
- Верифицировать запрет скриншотов на нужных экранах.
- Проверить, что без согласия телеметрия не отправляется, а логи не содержат PII.
- Проверить, что HTTP‑трафик блокируется при попытке cleartext; при MITM тестах pinning (если включён) корректно блокирует соединение.

### Безопасность/Релиз
- Регулярный аудит зависимостей и конфигурации R8/ProGuard.
- План по Certificate Pinning и ротации ключей бекенда.
- Периодические пентесты BLE‑канала и клиента (см. рекомендации в `03_BLE_PROTOCOL.md`).



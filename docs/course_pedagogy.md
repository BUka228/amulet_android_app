# Педагогическая логика курсов Amulet

## 1. Базовые принципы

- Курс — это **структурированный путь**, а не набор отдельных практик.
- Пользователь всегда понимает:
  - сколько займёт курс по времени (недели/дни);
  - какой **минимальный ритм** необходим, чтобы пройти курс в разумные сроки;
  - что именно он делает **сегодня** и **завтра**.
- В один временной слот (дата + время) приходится **не более одной практики** курса.
- Последовательность практик задаётся автором курса и **не нарушается** алгоритмом.
- Курс поддерживает **гибкость** (выбор дней/времени), но при этом сохраняет педагогический замысел.

## 2. Структура курса

### 2.1. Сущности

- **Course** — курс в целом.
- **CourseModule** — крупный блок курса (тема/неделя).
- **CourseItem / Practice** — конкретная практика.
- **CourseStep (логическая сущность в педагогике)**:
  - привязка практики к **дню учебного плана**;
  - может включать:
    - ссылку на practiceId;
    - `weekIndex` (1..N);
    - `dayIndex` внутри недели (1..7, не обязательно подряд);
    - тип шага (основная практика, повторение, интеграция, отдых).

### 2.2. Типовой учебный план

- Курс описывается как последовательность **шагов (CourseStep)**, разбитых по неделям.
- Пример (упрощённо):
  - Неделя 1:
    - День 1: вводная практика (основная);
    - День 2: простая техника (основная);
    - День 3: повторение + короткая интеграция;
    - День 4–7: опциональные доп. практики или отдых.
  - Неделя 2 и далее — аналогично.

Учебный план должен быть зафиксирован в данных курса (seed или отдельная структура), а не выдумываться на лету из списка `CourseItem`.

## 3. Ритмы и рекомендованная нагрузка

### 3.1. CourseRhythm

Курс имеет параметр `rhythm`, который определяет **минимальный рекомендуемый ритм**:

- `DAILY` — 5–7 учебных дней в неделю;
- `THREE_PER_WEEK` — 3 учебных дня в неделю;
- `TWO_PER_WEEK` — 2 учебных дня в неделю;
- `WEEKEND_ONLY` — 1–2 дня в выходные;
- (и др. варианты по необходимости).

### 3.2. RecommendedDays

Поле `recommendedDays` отражает **минимальное количество учебных дней в неделю**, при котором курс будет проходиться в задуманные автором сроки.

Примеры:

- Курс «Снижение стресса», рассчитанный на 3 недели при 3 днях в неделю:
  - `rhythm = THREE_PER_WEEK`;
  - `recommendedDays = 3`.

### 3.3. Взаимодействие с выбором пользователя

- Пользователь выбирает **дни недели** и **время суток**.
- Логика:
  - если пользователь выбирает **меньше дней**, чем `recommendedDays`:
    - курс **растягивается** на большее количество календарных недель;
    - UI честно показывает «при вашем ритме курс займёт ~X недель»;
  - если пользователь выбирает **больше дней**, чем `recommendedDays`:
    - допускается более плотное прохождение;
    - но в один день всё равно не ставится больше одной основной практики курса.

## 4. Алгоритм планирования курса

### 4.1. Входные данные

- Учебный план курса: список `CourseStep` с `(weekIndex, dayIndex, practiceId, type)`.
- Пользовательские настройки записи (`EnrollmentParams`):
  - выбранные дни недели (например, Пн, Ср, Пт);
  - предпочитаемое время;
  - дата старта.

### 4.2. Цели планировщика

- Сохранить **порядок** шагов курса.
- Разложить шаги по **реальным календарным датам**:
  - учитывая выбранные пользователем дни;
  - без перегруза: 1 слот = 1 шаг.
- Поддержать «растяжение» курса, если пользователь выбирает более редкий ритм.

### 4.3. Базовый алгоритм (production‑ready)

1. Построить последовательность "учебных дней" курса:
   - взять все `CourseStep` в порядке `(weekIndex, dayIndex, order)`;
   - проигнорировать шаги типа "отдых", если они явно не должны попадать в расписание.

2. Сгенерировать **календарную сетку** из пользовательского выбора:
   - от `startDate` и далее:
     - найти первые N дат, попадающих на выбранные пользователем дни недели;
     - при необходимости продолжать, пока не разложим все шаги курса.

3. Сопоставить шаги и даты:
   - для первого шага взять первую подходящую дату из сетки;
   - для второго шага — следующую доступную дату и т.д.;
   - если шагов больше, чем дат в одной "учебной неделе", продолжаем на следующую неделю (генерируем новые даты).

4. Построить `PracticeSchedule` / `ScheduledSession`:
   - для каждой пары (шаг, дата):
     - создать запись с `practiceId`, `courseId`, днём недели и временем;
     - **не создавать больше одной записи на одну дату и время** для данного курса и пользователя.

5. Обработка краевых случаев:
   - если у курса очень мало шагов (1–2 практики) и пользователь выбрал много дней:
     - можно либо завершить курс раньше,
     - либо предложить режим "поддерживающей практики" (повторные практики после завершения курса — опционально, отдельным флагом).

## 5. Специальный кейс: курс «Снижение стресса»

### 5.1. Пример учебного плана

(Схема, которую можно реализовать в seed‑данных.)

- Неделя 1:
  - День 1: Вводная практика / Осознанность для начинающих (основная);
  - День 3: Квадратное дыхание (основная);
  - День 5: Экспресс‑снятие стресса (основная).
- Неделя 2:
  - День 1: Сканирование тела (основная);
  - День 3: Осознанность для начинающих (повторение, интеграция);
  - День 5: Квадратное дыхание (повторение).
- Неделя 3:
  - и т.д., в зависимости от авторского замысла.

### 5.2. Как это выглядит для пользователя

- При выборе "3 дня в неделю" и времени 19:00:
  - в каждой учебной неделе будет **3 практики**, по одной в выбранные дни;
  - курс займёт, например, 3 календарные недели;
  - UI может показать: «Курс займёт ~3 недели при вашем ритме».

## 6. UX‑требования к отображению педагогики

- В hero‑блоке и мастере записи:
  - явно показывать:
    - ритм (например, «3 практики в неделю»);
    - ориентировочную длительность курса (например, «~3 недели»);
    - что именно пользователь выбрал (конкретные дни и время).
- Не создавать в один день видимость "спама" из 5–7 практик:
  - алгоритм жёстко ограничивает 1 практику курса на один слот расписания.
- При смене ритма или дней пользователем явно показывать, как меняется длительность курса.

## 7. Требования к реализации

- Вся педагогическая логика должна жить в **доменном слое** (use case’ы и модели), а не в UI.
- UI только:
  - отображает рассчитанный план;
  - даёт пользователю понятный фидбэк о длительности и ритме.
- Логика должна быть **детерминированной** и воспроизводимой:
  - при одинаковых входных данных (курс + выбор пользователя) план всегда одинаков.

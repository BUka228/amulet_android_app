## Контракты Data Layer — Репозитории

Цель: зафиксировать единый контракт для всех Репозиториев. Репозиторий — фасад для всех операций с данными, связанных с одной бизнес‑сущностью. Он полностью скрывает источники данных (сеть, БД, BLE) от доменного слоя и UI.

Основано на: Clean Architecture, модульные правила из `10_ARCHITECTURE`, обработка ошибок из `50_CROSS_CUTTING_CONCERNS/01_ERROR_HANDLING.md`, UI‑контракты из `40_PRESENTATION_LAYER/01_UI_STATE_MANAGEMENT.md`.

---

### 1. Назначение

- Репозиторий инкапсулирует политики консистентности (Local‑first, SWR, reconcile), кэширование (Room/DataStore), пагинацию (Paging 3) и каналы реального времени (FCM/BLE) для своей сущности.
- Репозиторий предоставляет стабильные доменные типы: принимает и возвращает ТОЛЬКО примитивы и доменные модели из `:shared`.
- Вся внутренняя инфраструктура (DTO, Entity, BLE‑клиенты) скрыта.

### 2. Именование

- Интерфейс в `:shared`: `[EntityName]Repository` (например, `HugsRepository`).
- Реализация в `:data:<entity>`: `[EntityName]RepositoryImpl`.

Пример модулей: `:shared` хранит интерфейс `HugsRepository`, а `:data:hugs` — реализацию `HugsRepositoryImpl` и все адаптеры (Retrofit/Room/BLE).

### 3. Зависимости (для реализации)

- Разрешено: `*ApiService` (Retrofit, в `:core:network`), `*Dao` (Room, в `:core:database`), `AmuletBleManager`/`AmuletBleClient` (в `:core:ble`), мапперы.
- Запрещено: зависимости на UseCase, ViewModel, UI/Compose, навигацию, Android UI‑API.
- DI: биндинг реализаций к интерфейсам выполняется в `:app` (см. `RepositoryBindingsModule`).

### 4. Контракт методов

- Входные параметры: только примитивы и доменные модели (`:shared`). НИКОГДА не принимать DTO/Entity.
- Возвраты и ошибки:
  - Одиночные операции (create/update/delete, детальные чтения): `suspend fun ...(): Result<T, AppError>`.
  - Потоки данных для списков/наблюдений: `fun ...(): Flow<List<T>>`, `Flow<PagingData<T>>` или `Flow<Result<T, AppError>>` там, где требуется сигнализация ошибок в потоке.
  - Внутри реализации обязательно использовать `safeApiCall { ... }` (для Retrofit) и/или `.asResult()` (для Flow) для маппинга исключений в `AppError` согласно единой стратегии ошибок.

Правила:
- Исключения из Data‑слоя не «протекают» наверх: все ошибки строго типизированы через `AppError`.
- Пагинация — через Paging 3: репозиторий возвращает `Flow<PagingData<DomainModel>>`. Источник истины — Room, `RemoteMediator` синхронизирует сеть и БД; ключи курсоров — в `remote_keys`.
- Реактивность: DAO возвращают `Flow`, репозиторий маппит сущности БД в доменные модели.

### 5. Обязательные практики реализации

- Мапперы: `Dto ↔ Domain`, `Entity ↔ Domain` в `:data:*`. Конверсия строго на границах слоёв.
- Безопасность корутин: пробрасывать `CancellationException`, не глотать отмену.
- Идемпотентность: использовать `upsert`/уникальные ключи в БД; для исходящих команд — outbox (см. `20_DATA_LAYER/01_DATABASE.md`).
- Telemetry/logging: ошибки логируются в инфраструктурных утилитах, а не в интерфейсах репозиториев.

### 6. Канонический пример контракта (HugsRepository)

```kotlin
// :shared — интерфейс (KMP‑совместим)
interface HugsRepository {
    // Поток пагинируемых «объятий» для выбранного направления
    fun getHugsStream(direction: HugDirection): Flow<PagingData<Hug>>

    // Одноразовая команда — отправка «объятия»
    suspend fun sendHug(draft: HugSendDraft): Result<Hug, AppError>

    // Получение деталей одной сущности
    suspend fun getHugDetails(hugId: HugId): Result<Hug, AppError>
}
```

### 7. Контракты для BLE/OTA‑операций в репозиториях

Если сущность требует операций с устройством (через `:core:ble`):
- Репозиторий остаётся фасадом: orchestration HTTP ↔ Room ↔ BLE выполняется внутри реализации.
- Исключения BLE маппятся в `AppError.BleError*` (см. стратегию ошибок).
- Долгие операции должны предоставлять реактивный прогресс: `fun uploadPattern(...): Flow<UploadProgress>` и/или возвращать `Result` по завершении.

### 8. Проверочный чек‑лист для новых репозиториев

- Интерфейс объявлен в `:shared` и оперирует доменными типами
- Реализация расположена в `:data:<entity>` и зависит только от разрешённых модулей
- Все сетевые вызовы через `safeApiCall`; все `Flow` снабжены `.asResult()` при необходимости
- Ошибки типизированы `AppError`; никаких `Throwable` наружу
- Пагинация — через Paging 3, источник истины — БД
- DTO/Entity не «просачиваются» выше Data‑слоя
- Бизнес‑политики консистентности локализованы внутри репозитория

---

Примечания:
- Для сложных сценариев координации нескольких репозиториев используйте оркестраторы в `:shared` (см. `01_ARCHITECTURE_OVERVIEW.md`, раздел «Оркестраторы бизнес‑процессов»).


